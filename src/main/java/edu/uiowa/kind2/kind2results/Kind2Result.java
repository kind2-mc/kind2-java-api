/*
 * Copyright (c) 2020, Board of Trustees of the University of Iowa
 * All rights reserved.
 *
 * Licensed under the BSD 3-Clause License. See LICENSE in the project root for license information.
 */

package edu.uiowa.kind2.kind2results;

import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;

import java.math.RoundingMode;
import java.util.*;
import java.util.stream.Collectors;

/**
 * The class is the top one in Kind2 explanations. An instance of this class is generated from kind2 json string
 * using the method {@link Kind2Result#analyzeJsonResult(String)}.
 * The returned instance contains a list of {@link Kind2NodeResult} which are the results of the sub-components.
 * It also contains a list of {@link Kind2Log} for the logs generated by kind2.
 * By default the returned instance uses the names in the lustre code, and surround them with {{}}.
 * These opening and closing symbols can be changed using the method {@link Kind2Result#setOpeningSymbols(String)}
 * and {@link Kind2Result#setClosingSymbols(String)} respectively.
 */
public class Kind2Result
{
  /**
   * Determines whether to print counter examples for falsifiable properties
   */
  private static boolean printingCounterExamplesEnabled = false;
  /**
   * Determines whether to print the last counter examples for unknown properties
   */
  private static boolean printingUnknownCounterExamplesEnabled = false;
  /**
   * Determines whether to print the line numbers of properties
   */
  private static boolean printingLineNumbersEnabled = false;
  /**
   * Determines the precision for printing real numbers
   */
  private static int realPrecision = 2;
  /**
   * See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/RoundingMode.html
   */
  private static RoundingMode realRoundingMode = RoundingMode.HALF_UP;
  /**
   * The opening symbols for printing lustre names
   */
  private static String openingSymbols = "{{";
  /**
   * The closing symbols for printing lustre names
   */
  private static String closingSymbols = "}}";
  /**
   * The top component in kind2 output.
   */
  private Kind2NodeResult root;
  /**
   * A mapping to store the results of sub-components.
   */
  private Map<String, Kind2NodeResult> resultMap = new HashMap<>();
  /**
   * The options used by kind2 process.
   */
  private final Kind2Options options;
  /**
   * Kind2 json output.
   */
  private final String json;
  /**
   * a list of kind2 logs.
   */
  private final List<Kind2Log> kind2Logs;

  /**
   * A private constructor that is used internally by {@link Kind2Result#analyzeJsonResult(String)}.
   * Use the static method {@link Kind2Result#analyzeJsonResult(String) to get a an instance of this class}.
   *
   * @param options   an object of {@link Kind2Options} which describes the options used by kind2 process.
   * @param jsonArray an array that captures all kind2 json output
   */
  private Kind2Result(Kind2Options options, JsonArray jsonArray)
  {
    this.options = options;
    json = new GsonBuilder().setPrettyPrinting().create().toJson(jsonArray);
    kind2Logs = new ArrayList<>();
  }

  /**
   * Store the result of kind2 analysis for the given node
   *
   * @param key      the name of the node
   * @param analysis the result of the analysis performed on the specified node
   */
  private void put(String key, Kind2Analysis analysis)
  {
    if (resultMap.containsKey(key))
    {
      resultMap.get(key).addAnalysis(analysis);
    }
    else
    {
      Kind2NodeResult nodeResult = new Kind2NodeResult(this, key);
      nodeResult.addAnalysis(analysis);
      resultMap.put(key, nodeResult);
      // root is the last analysis in kind2
      root = nodeResult;
    }
  }

  /**
   * @param nodeName the name of the node
   * @return {@link Kind2NodeResult} which contains the analyses performed by kind2 on the given node.
   */
  public Kind2NodeResult getNodeResult(String nodeName)
  {
    return resultMap.get(nodeName);
  }

  /**
   * wrapper for root.analyze().
   */
  private void analyze()
  {
    if (root == null)
    {
      // if the root object is null at this point, then we couldn't parse the json output properly.
      // It makes sense to throw kind2 errors found in the log objects.
      throwKind2Errors();
      return;
    }
    root.analyze();
  }

  /**
   * throw a {@link RuntimeException} if at least one of kind2 logs is error, fatal, or off.
   */
  private void throwKind2Errors()
  {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("An error has occurred during kind2 analysis. Please check the following logs:\n");
    boolean someError = false;
    for (Kind2Log log : kind2Logs)
    {
      if (log.getLevel() == Kind2LogLevel.error ||
          log.getLevel() == Kind2LogLevel.fatal ||
          log.getLevel() == Kind2LogLevel.off)
      {
        stringBuilder.append(log + "\n");
        someError = true;
      }
    }
    if (someError)
    {
      throw new RuntimeException(stringBuilder.toString());
    }
  }

  @Override
  public String toString()
  {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(root.toString());
    stringBuilder.append("Verification summary\n");
    stringBuilder.append(root.printVerificationSummary());
    return stringBuilder.toString();
  }

  /**
   * Analyze the json output of kind2 verification.
   *
   * @param json kind2 json output
   * @return {@link Kind2Result} which contains the result of analyzing kind2 output.
   */
  public static Kind2Result analyzeJsonResult(String json)
  {
    Kind2Result kind2Result = null;
    JsonArray resultArray = JsonParser.parseString(json).getAsJsonArray();
    Kind2Analysis kind2Analysis = null;
    // for post analysis
    Kind2Analysis previousAnalysis = null;

    for (JsonElement jsonElement : resultArray)
    {
      String objectType = jsonElement.getAsJsonObject().get(Kind2Labels.objectType).getAsString();
      Kind2Object kind2Object = Kind2Object.getKind2Object(objectType);

      if (kind2Object == Kind2Object.kind2Options)
      {
        Kind2Options options = new Kind2Options(jsonElement);
        kind2Result = new Kind2Result(options, resultArray);
      }

      if (kind2Object == Kind2Object.log && kind2Result != null)
      {
        Kind2Log log = new Kind2Log(kind2Result, jsonElement);
        kind2Result.kind2Logs.add(log);
      }

      if (kind2Object == Kind2Object.analysisStart)
      {
        // define new analysis
        kind2Analysis = new Kind2Analysis(jsonElement);
      }

      if (kind2Object == Kind2Object.analysisStop)
      {
        if (kind2Analysis != null)
        {
          // 	finish the analysis
          kind2Result.put(kind2Analysis.getNodeName(), kind2Analysis);
          previousAnalysis = kind2Analysis;
          kind2Analysis = null;
        }
        else
        {
          throw new RuntimeException("Failed to analyze kind2 json output");
        }
      }

      if (kind2Object == Kind2Object.property)
      {
        if (kind2Analysis != null)
        {
          Kind2Property property = new Kind2Property(kind2Analysis, jsonElement);
          kind2Analysis.addProperty(property);
        }
        else
        {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }

      if (kind2Object == Kind2Object.postAnalysisStart)
      {
        if (previousAnalysis != null)
        {
          Kind2PostAnalysis postAnalysis = new Kind2PostAnalysis(previousAnalysis, jsonElement);
          previousAnalysis.setPostAnalysis(postAnalysis);
        }
        else
        {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }

      if (kind2Object == Kind2Object.postAnalysisEnd)
      {
        if (previousAnalysis != null && previousAnalysis.getPostAnalysis() != null)
        {
          // 	finish the post analysis
          previousAnalysis = null;
        }
        else
        {
          throw new RuntimeException("Failed to analyze kind2 json output");
        }
      }

      if (kind2Object == Kind2Object.modelElementSet)
      {
        if (previousAnalysis != null && previousAnalysis.getPostAnalysis() != null)
        {
          Kind2PostAnalysis postAnalysis = previousAnalysis.getPostAnalysis();
          Kind2ModelElementSet elementSet = new Kind2ModelElementSet(postAnalysis, jsonElement);
          postAnalysis.addModelElementSet(elementSet);
        }
        else
        {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }
    }

    // build the node tree
    kind2Result.buildTree();
    // analyze the result
    kind2Result.analyze();

    return kind2Result;
  }

  /**
   * construct a tree of subcomponents.
   */
  private void buildTree()
  {
    for (Map.Entry<String, Kind2NodeResult> entry : resultMap.entrySet())
    {
      Kind2NodeResult nodeResult = entry.getValue();

      // we need this foreach loop to iterate through all analyses, and not just a single analysis.
      // There are some cases where the child nodes are not returned in concrete or abstract fields
      // and scattered across multiple analyses.

      for (Kind2Analysis analysis : nodeResult.getAnalyses())
      {
        List<String> subNodes = analysis.getSubNodes();

        for (String node : subNodes)
        {
          if (resultMap.containsKey(node))
          {
            nodeResult.addChild(resultMap.get(node));
          }
        }
      }
    }
  }

  /**
   * @return The wallclock timeout used for all the analyses
   */
  public double getTimeout()
  {
    return options.getTimeout();
  }

  /**
   * @return options used by kind2 process.
   */
  public Kind2Options getOptions()
  {
    return options;
  }

  /**
   * @return Kind2 json output.
   */
  public String getJson()
  {
    return json;
  }

  /**
   * @return {@link Kind2NodeResult} for the top component in kind2 output.
   */
  public Kind2NodeResult getRoot()
  {
    return root;
  }

  public Map<String, Kind2NodeResult> getResultMap()
  {
    return resultMap;
  }

  /**
   * @return a list of {@link Kind2Property} for all falsified properties including the falsified properties
   * for the subcomponents.
   */
  public Set<Kind2Property> getFalsifiedProperties()
  {
    return root.getFalsifiedProperties();
  }

  /**
   * @return a list of {@link Kind2Property} for all valid properties including the valid properties
   * for the subcomponents.
   */
  public Set<Kind2Property> getValidProperties()
  {
    return root.getValidProperties();
  }

  /**
   * @return a list of {@link Kind2Property} for all unknown properties including the unknown properties
   * for the subcomponents.
   */
  public Set<Kind2Property> getUnknownProperties()
  {
    return root.getUnknownProperties();
  }

  /**
   * @return {@code true} if printing counter examples for falsifiable properties is enabled.
   */
  public static boolean isPrintingCounterExamplesEnabled()
  {
    return printingCounterExamplesEnabled;
  }

  /**
   * Sets the value of printingCounterExamplesEnabled
   *
   * @param value
   */
  public static void setPrintingCounterExamplesEnabled(boolean value)
  {
    Kind2Result.printingCounterExamplesEnabled = value;
  }

  /**
   * @return a boolean that determines whether to print the last counter examples for unknown properties
   */
  public static boolean isPrintingUnknownCounterExamplesEnabled()
  {
    return printingUnknownCounterExamplesEnabled;
  }

  /**
   * Sets the value of printingUnknownCounterExamplesEnabled
   *
   * @param value
   */
  public static void setPrintingUnknownCounterExamplesEnabled(boolean value)
  {
    Kind2Result.printingUnknownCounterExamplesEnabled = value;
  }

  /**
   * @return a boolean that determines whether line numbers are printed
   */
  public static boolean isPrintingLineNumbersEnabled()
  {
    return printingLineNumbersEnabled;
  }

  /**
   * set the value of  printingLineNumbersEnabled
   *
   * @param value
   */
  public static void setPrintingLineNumbersEnabled(boolean value)
  {
    Kind2Result.printingLineNumbersEnabled = value;
  }

  /**
   * Set the opening symbols for printing lustre names
   *
   * @param symbols
   */
  public static void setOpeningSymbols(String symbols)
  {
    Kind2Result.openingSymbols = symbols;
  }

  /**
   * Set the opening symbols for printing lustre names
   *
   * @param symbols
   */
  public static void setClosingSymbols(String symbols)
  {
    Kind2Result.closingSymbols = symbols;
  }

  /**
   * @return returns the precision for printing real numbers
   */
  public static int getRealPrecision()
  {
    return realPrecision;
  }

  /**
   * Set the precision for printing real numbers
   */
  public static void setRealPrecision(int realPrecision)
  {
    Kind2Result.realPrecision = realPrecision;
  }

  /**
   * @return the rounding mode for real numbers
   */
  public static RoundingMode getRealRoundingMode()
  {
    return realRoundingMode;
  }

  /**
   * Set the rounding mode for real numbers
   *
   * @param realRoundingMode see https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/RoundingMode.html
   */
  public static void setRealRoundingMode(RoundingMode realRoundingMode)
  {
    Kind2Result.realRoundingMode = realRoundingMode;
  }

  /**
   * @return the opening symbols for printing lustre names
   */
  public static String getOpeningSymbols()
  {
    return openingSymbols;
  }

  /**
   * @return the closing symbols for printing lustre names
   */
  public static String getClosingSymbols()
  {
    return closingSymbols;
  }

  /**
   * @return a list of {@link Kind2Log} excluding hidden logs.
   */
  public List<Kind2Log> getKind2Logs()
  {
    return kind2Logs.stream().filter(l -> !l.isHidden()).collect(Collectors.toList());
  }

  /**
   * @return a list of {@link Kind2Log} for all kind2 logs.
   */
  public List<Kind2Log> getAllKind2Logs()
  {
    return kind2Logs;
  }
}
