/*
 * Copyright (c) 2020, Board of Trustees of the University of Iowa
 * All rights reserved.
 *
 * Licensed under the BSD 3-Clause License. See LICENSE in the project root for license information.
 */

package edu.uiowa.cs.clc.kind2.results;

import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import java.math.RoundingMode;
import java.util.*;
import java.util.stream.Collectors;

/**
 * The class is the top one in Kind2 explanations. An instance of this class is generated from kind2
 * json string using the method {@link Result#analyzeJsonResult(String)}. The returned instance
 * contains a list of {@link NodeResult} which are the results of the sub-components. It also
 * contains a list of {@link Log} for the logs generated by kind2. By default the returned instance
 * uses the names in the lustre code, and surround them with {{}}. These opening and closing symbols
 * can be changed using the method {@link Result#setOpeningSymbols(String)} and
 * {@link Result#setClosingSymbols(String)} respectively.
 */
public class Result {
  /**
   * Determines whether to print counter examples for falsifiable properties
   */
  private static boolean printingCounterExamplesEnabled = false;
  /**
   * Determines whether to print the last counter examples for unknown properties
   */
  private static boolean printingUnknownCounterExamplesEnabled = false;
  /**
   * Determines whether to print the line numbers of properties
   */
  private static boolean printingLineNumbersEnabled = false;
  /**
   * Determines the precision for printing real numbers
   */
  private static int realPrecision = 2;
  /**
   * See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/RoundingMode.html
   */
  private static RoundingMode realRoundingMode = RoundingMode.HALF_UP;
  /**
   * The opening symbols for printing lustre names
   */
  private static String openingSymbols = "{{";
  /**
   * The closing symbols for printing lustre names
   */
  private static String closingSymbols = "}}";
  /**
   * The top component in kind2 output.
   */
  private NodeResult root;
  /**
   * A mapping to store the results of sub-components.
   */
  private Map<String, NodeResult> resultMap = new HashMap<>();
  /**
   * The options used by kind2 process.
   */
  private Options options;
  /**
   * Kind2 json output.
   */
  private String json;
  /**
   * a list of kind2 logs.
   */
  private final List<Log> kind2Logs;
  /**
   * a list of kind2 AST infos.
   */
  private final List<AstInfo> astInfos;
  /**
   * Is this object properly initialized?
   */
  private boolean isInitialized;

  /**
   * a default constructor
   */
  public Result() {
    kind2Logs = new ArrayList<>();
    astInfos = new ArrayList<>();
    isInitialized = false;
  }

  /**
   * Store the result of kind2 analysis for the given node
   *
   * @param key the name of the node
   * @param analysis the result of the analysis performed on the specified node
   */
  private void put(String key, Analysis analysis) {
    if (resultMap.containsKey(key)) {
      resultMap.get(key).addAnalysis(analysis);
    } else {
      NodeResult nodeResult = new NodeResult(this, key);
      nodeResult.addAnalysis(analysis);
      resultMap.put(key, nodeResult);
      // root is the last analysis in kind2
      root = nodeResult;
    }
  }

  /**
   * @param nodeName the name of the node
   * @return {@link NodeResult} which contains the analyses performed by kind2 on the given node.
   */
  public NodeResult getNodeResult(String nodeName) {
    return resultMap.get(nodeName);
  }

  /**
   * wrapper for root.analyze().
   */
  private void analyze() {
    if (root == null) {
      // if the root object is null at this point, then we couldn't parse the json output properly.
      // It makes sense to throw kind2 errors found in the log objects.
      throwKind2Errors();
      return;
    }
    root.analyze();
  }

  /**
   * throw a {@link RuntimeException} if at least one of kind2 logs is error, fatal, or off.
   */
  private void throwKind2Errors() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder
        .append("An error has occurred during kind2 analysis. Please check the following logs:\n");
    boolean someError = false;
    for (Log log : kind2Logs) {
      if (log.getLevel() == LogLevel.error || log.getLevel() == LogLevel.fatal
          || log.getLevel() == LogLevel.off) {
        stringBuilder.append(log + "\n");
        someError = true;
      }
    }
    if (someError) {
      throw new RuntimeException(stringBuilder.toString());
    }
  }

  @Override
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(root.toString());
    stringBuilder.append("Verification summary\n");
    stringBuilder.append(root.printVerificationSummary());
    return stringBuilder.toString();
  }

  /**
   * Analyze the json output of kind2 verification.
   *
   * @param json kind2 json output
   * @return {@link Result} which contains the result of analyzing kind2 output.
   */
  public static Result analyzeJsonResult(String json) {
    Result kind2Result = new Result();

    kind2Result.initialize(json);

    return kind2Result;
  }

  public void initialize(String json) {
    JsonArray jsonArray = JsonParser.parseString(json).getAsJsonArray();
    this.json = new GsonBuilder().setPrettyPrinting().create().toJson(jsonArray);
    Analysis kind2Analysis = null;
    // for post analysis
    Analysis previousAnalysis = null;

    for (JsonElement jsonElement : jsonArray) {
      String objectType = jsonElement.getAsJsonObject().get(Labels.objectType).getAsString();
      Object kind2Object = Object.getKind2Object(objectType);

      if (kind2Object == Object.kind2Options) {
        Options options = new Options(jsonElement);

        this.options = options;
      }

      if (kind2Object == Object.log) {
        Log log = new Log(this, jsonElement);
        this.kind2Logs.add(log);
      }

      if (kind2Object == Object.lsp) {
        JsonObject jsonObject = jsonElement.getAsJsonObject();
        String kind = jsonObject.get(Labels.kind).getAsString();
        AstInfo astInfo;
        switch (kind) {
          case "typeDecl":
            astInfo = new TypeDeclInfo(jsonElement);
            break;
          case "constDecl":
            astInfo = new ConstDeclInfo(jsonElement);
            break;
          case "node":
            astInfo = new NodeInfo(jsonElement);
            break;
          case "function":
            astInfo = new FunctionInfo(jsonElement);
            break;
          case "contract":
            astInfo = new ContractInfo(jsonElement);
            break;
          default:
            throw new RuntimeException("Failed to analyze kind2 json output");
        }
        this.astInfos.add(astInfo);
      }

      if (kind2Object == Object.analysisStart) {
        // define new analysis
        kind2Analysis = new Analysis(jsonElement);
      }

      if (kind2Object == Object.analysisStop) {
        if (kind2Analysis != null) {
          // finish the analysis
          this.put(kind2Analysis.getNodeName(), kind2Analysis);
          previousAnalysis = kind2Analysis;
          kind2Analysis = null;
        } else {
          throw new RuntimeException("Failed to analyze kind2 json output");
        }
      }

      if (kind2Object == Object.property) {
        if (kind2Analysis != null) {
          Property property = new Property(kind2Analysis, jsonElement);
          kind2Analysis.addProperty(property);
        } else {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }

      if (kind2Object == Object.realizabilityCheck) {
        if (kind2Analysis != null) {
          JsonObject jsonObject = jsonElement.getAsJsonObject();
          String res = jsonObject.get(Labels.result).getAsString();
          if (res.equals(Labels.realizable)) {
            kind2Analysis.setRealizabilityCheck(true);
          } else {
            kind2Analysis.setRealizabilityCheck(false);
          }
          JsonElement deadlockElement = jsonObject.get(Labels.deadlockingTrace);
          String deadlock = new GsonBuilder().setPrettyPrinting().create().toJson(deadlockElement);
          kind2Analysis.setDeadlock(deadlock);
        } else {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }

      if (kind2Object == Object.postAnalysisStart) {
        if (previousAnalysis != null) {
          PostAnalysis postAnalysis = new PostAnalysis(previousAnalysis, jsonElement);
          previousAnalysis.setPostAnalysis(postAnalysis);
        } else {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }

      if (kind2Object == Object.postAnalysisEnd) {
        if (previousAnalysis != null && previousAnalysis.getPostAnalysis() != null) {
          // finish the post analysis
          previousAnalysis = null;
        } else {
          throw new RuntimeException("Failed to analyze kind2 json output");
        }
      }

      if (kind2Object == Object.modelElementSet) {
        if (previousAnalysis != null && previousAnalysis.getPostAnalysis() != null) {
          PostAnalysis postAnalysis = previousAnalysis.getPostAnalysis();
          ModelElementSet elementSet = new ModelElementSet(postAnalysis, jsonElement);
          postAnalysis.addModelElementSet(elementSet);
        } else {
          throw new RuntimeException("Can not parse kind2 json output");
        }
      }
    }

    // build the node tree
    this.buildTree();
    // analyze the result
    this.analyze();
    isInitialized = true;
  }

  /**
   * construct a tree of subcomponents.
   */
  private void buildTree() {
    for (Map.Entry<String, NodeResult> entry : resultMap.entrySet()) {
      NodeResult nodeResult = entry.getValue();

      // we need this foreach loop to iterate through all analyses, and not just a single analysis.
      // There are some cases where the child nodes are not returned in concrete or abstract fields
      // and scattered across multiple analyses.

      for (Analysis analysis : nodeResult.getAnalyses()) {
        List<String> subNodes = analysis.getSubNodes();

        for (String node : subNodes) {
          if (resultMap.containsKey(node)) {
            nodeResult.addChild(resultMap.get(node));
          }
        }
      }
    }
  }

  /**
   * @return The wallclock timeout used for all the analyses
   */
  public double getTimeout() {
    return options.getTimeout();
  }

  /**
   * @return options used by kind2 process.
   */
  public Options getOptions() {
    return options;
  }

  /**
   * @return Kind2 json output.
   */
  public String getJson() {
    return json;
  }

  /**
   * @return {@link NodeResult} for the top component in kind2 output.
   */
  public NodeResult getRoot() {
    return root;
  }

  public Map<String, NodeResult> getResultMap() {
    return resultMap;
  }

  /**
   * @return a list of {@link Property} for all falsified properties including the falsified
   *         properties for the subcomponents.
   */
  public Set<Property> getFalsifiedProperties() {
    if (root == null) {
      return new HashSet<>();
    }
    return root.getFalsifiedProperties();
  }

  /**
   * @return a list of {@link Property} for all valid properties including the valid properties for
   *         the subcomponents.
   */
  public Set<Property> getValidProperties() {
    if (root == null) {
      return new HashSet<>();
    }
    return root.getValidProperties();
  }

  /**
   * @return a list of {@link Property} for all unknown properties including the unknown properties
   *         for the subcomponents.
   */
  public Set<Property> getUnknownProperties() {
    if (root == null) {
      return new HashSet<>();
    }
    return root.getUnknownProperties();
  }

  /**
   * @return a list of {@link Property} for all reachable properties including the reachable properties for
   *         the subcomponents.
   */
  public Set<Property> getReachableProperties() {
    if (root == null) {
      return new HashSet<>();
    }
    return root.getReachableProperties();
  }

  /**
   * @return a list of {@link Property} for all unreachable properties including the unreachable properties for
   *         the subcomponents.
   */
  public Set<Property> getUnreachableProperties() {
    if (root == null) {
      return new HashSet<>();
    }
    return root.getUnreachableProperties();
  }

  /**
   * @return {@code true} if printing counter examples for falsifiable properties is enabled.
   */
  public static boolean isPrintingCounterExamplesEnabled() {
    return printingCounterExamplesEnabled;
  }

  /**
   * Sets the value of printingCounterExamplesEnabled
   *
   * @param value
   */
  public static void setPrintingCounterExamplesEnabled(boolean value) {
    Result.printingCounterExamplesEnabled = value;
  }

  /**
   * @return a boolean that determines whether to print the last counter examples for unknown
   *         properties
   */
  public static boolean isPrintingUnknownCounterExamplesEnabled() {
    return printingUnknownCounterExamplesEnabled;
  }

  /**
   * Sets the value of printingUnknownCounterExamplesEnabled
   *
   * @param value
   */
  public static void setPrintingUnknownCounterExamplesEnabled(boolean value) {
    Result.printingUnknownCounterExamplesEnabled = value;
  }

  /**
   * @return a boolean that determines whether line numbers are printed
   */
  public static boolean isPrintingLineNumbersEnabled() {
    return printingLineNumbersEnabled;
  }

  /**
   * set the value of printingLineNumbersEnabled
   *
   * @param value
   */
  public static void setPrintingLineNumbersEnabled(boolean value) {
    Result.printingLineNumbersEnabled = value;
  }

  /**
   * Set the opening symbols for printing lustre names
   *
   * @param symbols
   */
  public static void setOpeningSymbols(String symbols) {
    Result.openingSymbols = symbols;
  }

  /**
   * Set the opening symbols for printing lustre names
   *
   * @param symbols
   */
  public static void setClosingSymbols(String symbols) {
    Result.closingSymbols = symbols;
  }

  /**
   * @return returns the precision for printing real numbers
   */
  public static int getRealPrecision() {
    return realPrecision;
  }

  /**
   * Set the precision for printing real numbers
   */
  public static void setRealPrecision(int realPrecision) {
    Result.realPrecision = realPrecision;
  }

  /**
   * @return the rounding mode for real numbers
   */
  public static RoundingMode getRealRoundingMode() {
    return realRoundingMode;
  }

  /**
   * Set the rounding mode for real numbers
   *
   * @param realRoundingMode see
   *        https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/RoundingMode.html
   */
  public static void setRealRoundingMode(RoundingMode realRoundingMode) {
    Result.realRoundingMode = realRoundingMode;
  }

  /**
   * @return the opening symbols for printing lustre names
   */
  public static String getOpeningSymbols() {
    return openingSymbols;
  }

  /**
   * @return the closing symbols for printing lustre names
   */
  public static String getClosingSymbols() {
    return closingSymbols;
  }

  /**
   * @return a list of {@link Log} excluding hidden logs.
   */
  public List<Log> getKind2Logs() {
    return kind2Logs.stream().filter(l -> !l.isHidden()).collect(Collectors.toList());
  }

  /**
   * @return a list of {@link AstInfo}.
   */
  public List<AstInfo> getAstInfos() {
    return astInfos;
  }

  /**
   * @return a list of {@link Log} for all kind2 logs.
   */
  public List<Log> getAllKind2Logs() {
    return kind2Logs;
  }

  /**
   * @return whether or not this object is properly initialized.
   */
  public boolean isInitialized() {
    return isInitialized;
  }
}
